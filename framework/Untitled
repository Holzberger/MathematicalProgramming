	for( u_int i = 0; i <  instance.n_edges; i++ ) {
		model.add(f[instance.edges[i].v1] + x[i] <= f[instance.edges[i].v2] + k*(1-x[i]) );
	}
	
	IloExpr sum_x( env );
	for( u_int i = 0; i <  instance.n_edges; i++ ) {
		sum_x += x[i];
	}
	model.add(sum_x == k-1);
	sum_x.clear();
	
	for( u_int i = 0; i <  instance.n_edges; i++ ) {
		if(instance.edges[i].v1 == 0)
			sum_x += x[i];
	}
	model.add(sum_x == 1);
	sum_x.clear();
	
	for( u_int j = 1; j <  instance.n_nodes; j++ ) { // not root
		for( u_int ie = 0; ie <  instance.n_edges; ie++ ) {
			if(instance.edges[ie].v2 == j)
				sum_x += x[ie];
		}
		model.add(sum_x <= 1);
		sum_x.clear();







		for( u_int i = 0; i <  instance.n_edges; i++ ) {
			model.add(f[instance.edges[i].v1] + x[i] <= f[instance.edges[i].v2] + k*(1-x[i]) );
		}
		
		for( u_int j = 1; j <  instance.n_nodes; j++ ) {
			for( u_int ie = 0; ie <  instance.n_edges; ie++ ) {
				if(instance.edges[ie].v2 == j)
					edge_expr += x[ie];
			}
		model.add(0 <= k*edge_expr - f[j]);
		edge_expr.clear();
		}

----------------------------------------------------------------------



		IloExpr flow_expr( env );
		IloExpr edge_expr( env );
		
		
		for( u_int i = 0; i <  instance.n_edges; i++ ) {
		if(instance.edges[i].v1 == 0)
			edge_expr += x[i];
		}
		model.add(edge_expr == 1);
		edge_expr.clear();
		
		for( u_int j = 1; j <  instance.n_nodes; j++ ) {
			for( u_int i = 0; i <  instance.n_edges; i++ ) {
				if(instance.edges[i].v2 == j)
					edge_expr += x[i];
			}
		model.add(0 >= k*(1-edge_expr) - f[j]);
		edge_expr.clear();
		}

		for( u_int i = 0; i <  instance.n_edges; i++ ) {
			edge_expr += x[i];
		}
		model.add(edge_expr == k);
		edge_expr.clear();
		
		for( u_int i = 0; i <  instance.n_edges; i++ ) {
		model.add(f[instance.edges[i].v1] + x[i] <= f[instance.edges[i].v2] + k*(1-x[i]) );
		}

		// root has exactly one outgoing edge
		for( u_int i = 0; i <  instance.n_edges; i++ ) {
			if(instance.edges[i].v1==0)
				sum_x += x[i];
		}
		model.add(sum_x == 1);
		sum_x.clear();
		
		
		----------------------------------------------------------------------------------------
		
		
		
		x = IloBoolVarArray(env, instance.n_edges);
		z = IloBoolVarArray(env, instance.n_nodes);
		f = IloIntVarArray(env);
		f.add(IloIntVarArray(env, instance.n_edges*2, 0, k));
		
		for( u_int i = 0; i <  instance.n_edges*2; i+=2 ) {
			model.add(f[i] <= k*x[i/2]);
			model.add(f[i+1] <= k*x[i/2]);
		}
		
		IloExpr objective( env );
		for( u_int i = 0; i <  instance.n_edges; i++ ) {
			objective += x[i]*instance.edges[i].weight;
		}
		model.add(IloMinimize(env, objective));
		
		IloExpr sum_x( env );
		
		// root has exactly one outgoing edge with flow k
		for( u_int i = 0; i <  instance.n_edges*2; i+=2 ) {
			if(instance.edges[i/2].v1==0)
				model.add(f[i] == k*x[i/2]);
			if(instance.edges[i/2].v2==0)
				model.add(f[i+1] == k*x[i/2]);
			
		}

		

		
		// send nothing back to root
		for( u_int i = 0; i <  instance.n_edges*2; i+=2 ) {
			if(instance.edges[i/2].v1 ==0)
				sum_x += f[i+1];
			if(instance.edges[i/2].v2 ==0)
				sum_x += f[i];
		}
		model.add(sum_x == 0);
		sum_x.clear();
		
		
		
		IloExpr sum_z( env );
		
		// select exactly k+1 nodes
		for( u_int i = 0; i <  instance.n_nodes; i++ ) {
			sum_z += z[i];
		}
		model.add(sum_z == k+1);
		sum_z.clear();
		
		
		// select exactly k edges
		for( u_int i = 0; i <  instance.n_edges; i++ ) {
			sum_x += x[i];
		}
		model.add(sum_x == k);
		sum_x.clear();
		
		for( u_int j = 1; j < instance.n_nodes; j++ ){
			for( u_int i = 0; i <  instance.n_edges*2; i+=2 ) {
				if(instance.edges[i/2].v1 ==j)
					sum_x += -f[i] + f[i+1];
				if(instance.edges[i/2].v2 ==j)
					sum_x +=  f[i] - f[i+1];
			}
			model.add(sum_x == z[j]);
			sum_x.clear();
		}
		
		sum_z.end();
		sum_x.end();
		objective.end();
		
	---------------------------------------------------------------------------
	
	// flow continuity
		for( u_int j = 1; j < instance.n_nodes; j++ ){ // not for root
			for( u_int i = 0; i <  instance.n_edges*2; i+=2 ) {
				if(instance.edges[i/2].v1 ==j)
					sum_x += -f[i] + f[i+1];
				if(instance.edges[i/2].v2 ==j)
					sum_x +=  f[i] - f[i+1];
			}
			model.add(sum_x == -1);
			sum_x.clear();
		}
		
		// select arc whenever there is a flow
		for( u_int i = 0; i <  instance.n_edges*2; i+=2 ) {
			model.add(f[i] <= k*x[i]);
			model.add(f[i+1] <= k*x[i+1]);
		}
		
		
		// root has exactly one outgoing edge with flow k
		for( u_int i = 0; i <  instance.n_edges*2; i+=2 ) {
			if(instance.edges[i/2].v1==0){
				model.add(f[i] == k*x[i]);
				sum_x  += x[i]; 
				sum_x1 += x[i+1];
			}
			if(instance.edges[i/2].v2==0){
				model.add(f[i+1] == k*x[i+1]);
				sum_x  += x[i+1];
				sum_x1 += x[i];
			}
		}
		model.add(sum_x == 1);
		model.add(sum_x1 == 0);
		sum_x.clear();
		sum_x1.clear();
		
		// flow continuity
		for( u_int j = 1; j < instance.n_nodes; j++ ){ // not for root
			for( u_int i = 0; i <  instance.n_edges*2; i+=2 ) {
				if(instance.edges[i/2].v1 ==j)
					sum_x += -f[i] + f[i+1];
				if(instance.edges[i/2].v2 ==j)
					sum_x +=  f[i] - f[i+1];
			}
			model.add(sum_x == -1);
			sum_x.clear();
		}
		
		// select arc whenever there is a flow
		//for( u_int i = 0; i <  instance.n_edges*2; i+=2 ) {
		//	model.add(f[i] <= k*x[i]);
		//	model.add(f[i+1] <= k*x[i+1]);
		//}
		
